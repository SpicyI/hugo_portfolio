<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Minishell | Spicy&#39;s Portfolio</title>
<meta name="keywords" content="">
<meta name="description" content="Minishell: Minishell is a simplified Unix shell implementation, built as a programming project. It provides a command-line interface that allows users to interact with the operating system by executing commands.
This project aims to recreate a subset of the functionalities found in a traditional Unix shell. It serves as an exercise in systems programming and provides an opportunity to understand the inner workings of a shell environment.
Objective: Objective: To create a simplified shell or command-line interpreter, similar to the Unix/Linux shell (e.">
<meta name="author" content="">
<link rel="canonical" href="/portfolio/project1/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="favicon-32x32.png">
<link rel="apple-touch-icon" href="apple-touch-icon.png">
<link rel="mask-icon" href="safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Minishell" />
<meta property="og:description" content="Minishell: Minishell is a simplified Unix shell implementation, built as a programming project. It provides a command-line interface that allows users to interact with the operating system by executing commands.
This project aims to recreate a subset of the functionalities found in a traditional Unix shell. It serves as an exercise in systems programming and provides an opportunity to understand the inner workings of a shell environment.
Objective: Objective: To create a simplified shell or command-line interpreter, similar to the Unix/Linux shell (e." />
<meta property="og:type" content="article" />
<meta property="og:url" content="/portfolio/project1/" />
<meta property="og:image" content="https://cdn.ttgtmedia.com/rms/onlineimages/REF_bash_command_line_3_mobile.jpg" /><meta property="article:section" content="portfolio" />
<meta property="article:published_time" content="2023-09-09T16:21:26+00:00" />
<meta property="article:modified_time" content="2023-09-09T16:21:26+00:00" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://cdn.ttgtmedia.com/rms/onlineimages/REF_bash_command_line_3_mobile.jpg" />
<meta name="twitter:title" content="Minishell"/>
<meta name="twitter:description" content="Minishell: Minishell is a simplified Unix shell implementation, built as a programming project. It provides a command-line interface that allows users to interact with the operating system by executing commands.
This project aims to recreate a subset of the functionalities found in a traditional Unix shell. It serves as an exercise in systems programming and provides an opportunity to understand the inner workings of a shell environment.
Objective: Objective: To create a simplified shell or command-line interpreter, similar to the Unix/Linux shell (e."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Portfolios",
      "item": "/portfolio/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Minishell",
      "item": "/portfolio/project1/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Minishell",
  "name": "Minishell",
  "description": "Minishell: Minishell is a simplified Unix shell implementation, built as a programming project. It provides a command-line interface that allows users to interact with the operating system by executing commands.\nThis project aims to recreate a subset of the functionalities found in a traditional Unix shell. It serves as an exercise in systems programming and provides an opportunity to understand the inner workings of a shell environment.\nObjective: Objective: To create a simplified shell or command-line interpreter, similar to the Unix/Linux shell (e.",
  "keywords": [
    
  ],
  "articleBody": "Minishell: Minishell is a simplified Unix shell implementation, built as a programming project. It provides a command-line interface that allows users to interact with the operating system by executing commands.\nThis project aims to recreate a subset of the functionalities found in a traditional Unix shell. It serves as an exercise in systems programming and provides an opportunity to understand the inner workings of a shell environment.\nObjective: Objective: To create a simplified shell or command-line interpreter, similar to the Unix/Linux shell (e.g., Bash).\nKey Concepts and Learning Objectives: Processes and Forking: Students learn about creating processes using the fork() system call. They must understand how to create child processes, which execute shell commands, and how the parent process manages them. System Calls: This project involves using essential system calls such as fork(), execve(), wait(), pipe(), and dup2(). Students learn how these calls work and how to use them effectively. Command Parsing: Parsing user input and breaking it down into commands and arguments is a critical part of building a shell. Students must implement a parser to handle command-line arguments and redirection. Built-in Commands: In addition to external commands, students implement a set of built-in commands, such as cd, echo, and env, which are executed by the shell directly without invoking external programs. Redirection and Piping: Students learn how to handle I/O redirection (e.g., \u003c, \u003e, Â») and piping (e.g., |) between commands. Environment Variables: Managing environment variables (e.g., PATH, HOME, USER) is an essential part of the shell. Students must implement functions to get, set, and manage environment variables. Signal Handling: Understanding and handling signals (e.g., Ctrl+C, Ctrl+D) is crucial for a shell. Students must ensure the shell can manage signals gracefully. Error Handling: Effective error handling is essential to provide informative feedback to users when things go wrong. Shell Prompt: Students often create a customized shell prompt that displays information like the current directory, username, hostname, etc. User Interaction: The shell should provide a command-line interface where users can interact with the system, execute commands, and navigate directories. Challenges: Building a shell is a complex task that requires a deep understanding of system programming concepts, including process management, file descriptors, and system calls. Handling edge cases and ensuring proper error handling can be challenging. Useful Skills: This project helps students develop skills in C programming, system calls, process management, input/output handling, and error handling. It also deepens their understanding of how a shell works internally. Project Extensions: Some students take this project further by implementing additional features like job control, scripting support, and more advanced redirection options. Features Command Parsing: Minishell parses user input to identify and interpret commands, arguments, and options. Process Management: It handles process creation, execution, and termination, allowing users to run commands and external programs. Built-in Commands: The shell supports a set of built-in commands, such as cd for changing directories and exit for terminating the shell. Redirection and Pipes: Minishell supports input/output redirection, allowing users to redirect input and output streams. It also enables the piping of commands, allowing the output of one command to serve as input to another. Environment Variables: The shell supports the creation and management of environment variables. Signal Handling: Minishell handles signals such as Ctrl-C and Ctrl-\\ to terminate or suspend the shell. Installation Clone the repo git clone https://github.com/SpicyI/minishell.git Make sure to install the readline library brew install readline and set the path to the library in the Makefile LD_FLAGS = -L/Users/$(USER)/.brew/opt/readline/lib -lreadline INC_FLAGS = -I/Users/$(USER)/.brew/opt/readline/include Run make Conclusion This project serves as an educational tool to deepen understanding of fundamental operating system concepts, process management, and command-line interfaces. By implementing a subset of shell functionalities, users can gain hands-on experience and enhance their programming skills in a system-level environment.\nPlease note that while Minishell aims to replicate some features of a real shell, it may not support the entire range of complex features found in production-level shells like Bash or Zsh.\n",
  "wordCount" : "655",
  "inLanguage": "en",
  "image":"https://cdn.ttgtmedia.com/rms/onlineimages/REF_bash_command_line_3_mobile.jpg","datePublished": "2023-09-09T16:21:26Z",
  "dateModified": "2023-09-09T16:21:26Z",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "/portfolio/project1/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Spicy's Portfolio",
    "logo": {
      "@type": "ImageObject",
      "url": "favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="" accesskey="h" title="My Portfolio (Alt + H)">My Portfolio</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Minishell
    </h1>
    <div class="post-meta"><span title='2023-09-09 16:21:26 +0000 UTC'>September 9, 2023</span>&nbsp;|&nbsp;<a href="https://github.com/SpicyI/Minishell" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> 
<figure class="entry-cover"><img loading="lazy" src="https://cdn.ttgtmedia.com/rms/onlineimages/REF_bash_command_line_3_mobile.jpg" alt="shell picture">
        
</figure><div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#minishell" aria-label="Minishell:">Minishell:</a></li>
                <li>
                    <a href="#objective" aria-label="Objective:">Objective:</a></li>
                <li>
                    <a href="#key-concepts-and-learning-objectives" aria-label="Key Concepts and Learning Objectives:">Key Concepts and Learning Objectives:</a><ul>
                        
                <li>
                    <a href="#features" aria-label="Features">Features</a></li>
                <li>
                    <a href="#installation" aria-label="Installation">Installation</a></li>
                <li>
                    <a href="#conclusion" aria-label="Conclusion">Conclusion</a>
                </li>
            </ul>
            </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h1 id="minishell">Minishell:<a hidden class="anchor" aria-hidden="true" href="#minishell">#</a></h1>
<p>Minishell is a simplified Unix shell implementation, built as a programming project. It provides a command-line interface that allows users to interact with the operating system by executing commands.</p>
<p>This project aims to recreate a subset of the functionalities found in a traditional Unix shell. It serves as an exercise in systems programming and provides an opportunity to understand the inner workings of a shell environment.</p>
<h1 id="objective">Objective:<a hidden class="anchor" aria-hidden="true" href="#objective">#</a></h1>
<p>Objective: To create a simplified shell or command-line interpreter, similar to the Unix/Linux shell (e.g., Bash).</p>
<h1 id="key-concepts-and-learning-objectives">Key Concepts and Learning Objectives:<a hidden class="anchor" aria-hidden="true" href="#key-concepts-and-learning-objectives">#</a></h1>
<ul>
<li><strong>Processes</strong> and Forking: Students learn about creating processes using the fork() system call. They must understand how to create child processes, which execute shell commands, and how the parent process manages them.</li>
<li><strong>System Calls</strong>: This project involves using essential system calls such as fork(), execve(), wait(), pipe(), and dup2(). Students learn how these calls work and how to use them effectively.</li>
<li><strong>Command Parsing</strong>: Parsing user input and breaking it down into commands and arguments is a critical part of building a shell. Students must implement a parser to handle command-line arguments and redirection.</li>
<li><strong>Built-in Commands</strong>: In addition to external commands, students implement a set of built-in commands, such as cd, echo, and env, which are executed by the shell directly without invoking external programs.</li>
<li><strong>Redirection and Piping</strong>: Students learn how to handle I/O redirection (e.g., &lt;, &gt;, &raquo;) and piping (e.g., |) between commands.</li>
<li><strong>Environment Variables</strong>: Managing environment variables (e.g., PATH, HOME, USER) is an essential part of the shell. Students must implement functions to get, set, and manage environment variables.</li>
<li><strong>Signal Handling</strong>: Understanding and handling signals (e.g., Ctrl+C, Ctrl+D) is crucial for a shell. Students must ensure the shell can manage signals gracefully.</li>
<li><strong>Error Handling</strong>: Effective error handling is essential to provide informative feedback to users when things go wrong.</li>
<li><strong>Shell Prompt</strong>: Students often create a customized shell prompt that displays information like the current directory, username, hostname, etc.</li>
<li><strong>User Interaction</strong>: The shell should provide a command-line interface where users can interact with the system, execute commands, and navigate directories.</li>
<li><strong>Challenges</strong>: Building a shell is a complex task that requires a deep understanding of system programming concepts, including process management, file descriptors, and system calls. Handling edge cases and ensuring proper error handling can be challenging.</li>
<li><strong>Useful Skills</strong>: This project helps students develop skills in C programming, system calls, process management, input/output handling, and error handling. It also deepens their understanding of how a shell works internally.</li>
<li><strong>Project Extensions</strong>: Some students take this project further by implementing additional features like job control, scripting support, and more advanced redirection options.</li>
</ul>
<h2 id="features">Features<a hidden class="anchor" aria-hidden="true" href="#features">#</a></h2>
<ul>
<li>Command Parsing: Minishell parses user input to identify and interpret commands, arguments, and options.</li>
<li>Process Management: It handles process creation, execution, and termination, allowing users to run commands and external programs.</li>
<li>Built-in Commands: The shell supports a set of built-in commands, such as <code>cd</code> for changing directories and <code>exit</code> for terminating the shell.</li>
<li>Redirection and Pipes: Minishell supports input/output redirection, allowing users to redirect input and output streams. It also enables the piping of commands, allowing the output of one command to serve as input to another.</li>
<li>Environment Variables: The shell supports the creation and management of environment variables.</li>
<li>Signal Handling: Minishell handles signals such as <code>Ctrl-C</code> and <code>Ctrl-\</code> to terminate or suspend the shell.</li>
</ul>
<h2 id="installation">Installation<a hidden class="anchor" aria-hidden="true" href="#installation">#</a></h2>
<ol>
<li>Clone the repo
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>git clone https://github.com/SpicyI/minishell.git
</span></span></code></pre></div></li>
<li>Make sure to install the readline library
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span>brew install readline
</span></span></code></pre></div>and set the path to the library in the Makefile
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-sh" data-lang="sh"><span style="display:flex;"><span> LD_FLAGS <span style="color:#f92672">=</span> -L/Users/<span style="color:#66d9ef">$(</span>USER<span style="color:#66d9ef">)</span>/.brew/opt/readline/lib -lreadline
</span></span><span style="display:flex;"><span> INC_FLAGS <span style="color:#f92672">=</span> -I/Users/<span style="color:#66d9ef">$(</span>USER<span style="color:#66d9ef">)</span>/.brew/opt/readline/include
</span></span></code></pre></div></li>
<li>Run make</li>
</ol>
<h2 id="conclusion">Conclusion<a hidden class="anchor" aria-hidden="true" href="#conclusion">#</a></h2>
<p>This project serves as an educational tool to deepen understanding of fundamental operating system concepts, process management, and command-line interfaces. By implementing a subset of shell functionalities, users can gain hands-on experience and enhance their programming skills in a system-level environment.</p>
<p>Please note that while Minishell aims to replicate some features of a real shell, it may not support the entire range of complex features found in production-level shells like Bash or Zsh.</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
<nav class="paginav">
  <a class="next" href="/portfolio/project2/">
    <span class="title">Next Â»</span>
    <br>
    <span>Cub3D</span>
  </a>
</nav>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="">Spicy&#39;s Portfolio</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
